(ns plugin.respond)

(defn search-for 
  ([string] (search-for string "" 0))
  ([string flags] (search-for string flags 0))
  ([string flags stopline]
   (execute (str "keepjumps call search(\""
                string "\", \"" flags "\", "
                 stopline ")"))
   (#*line ".")))

(defn jump-to-line [linenum]
  (execute (str "keepjumps normal! " linenum "G")))

(defn current-class-range []
  (let [window-pos (#*winsaveview)
        curline (#*line ".")
        first-line (search-for "React.createClass" "b")]
    (execute "keepjumps normal! $%")
    (let [result [first-line (#*line ".")]]
      (jump-to-line curline)
      (#*winrestview window-pos)
      result)))

(def function-mneumonics
  {"cdm"  "componentDidMount"
   "cdup" "componentDidUpdate"
   "cwm"  "componentWillMount"
   "cwr"  "componentWillReceiveProps"
   "cwun" "componentWillUnmount"
   "cwu"  "componentWillUpdate"
   "gdp"  "getDefaultProps"
   "gis"  "getInitialState"
   "pt"   "propTypes"
   "r"    "render"
   "scu"  "shouldComponentUpdate"})

(def object? #{"propTypes"})

(def args-mappings
  {"componentDidUpdate"        "prevProps, prevState"
   "componentWillReceiveProps" "nextProps"
   "componentWillUpdate"       "nextProps, nextState"
   "shouldComponentUpdate"     "nextProps, nextState"})

(defn args-for [function-name]
  (args-mappings function-name ""))

(defn definition-for [function-name]
  (if (object? function-name)
    (str function-name ": {")
    (str function-name ": function(" (args-for function-name) ") {")))

; normal! is preferable because it ignores user mappings
(defn norm [input] (execute (str "normal! " input)))

(defn parse-class []
  (let [[first-line last-line] (current-class-range)]
    (jump-to-line first-line)
    (norm "j")
    (loop [methods []]
      (if (< (#*line ".") last-line)
        (do (#*search #"(\w+: function|propTypes:)")
            (let [cword (#*expand "<cword>")
                  lnum (#*line ".")]
              (execute "keepjumps normal! $%j")
              (recur (conj methods 
                           {:name cword
                            :start-line lnum
                            :end-line (dec (#*line "."))}
                           ))))
        (let [last-method (last methods)
              without-last (butlast methods)
              marked-as-last (conj last-method [:is-last true])
              methods (conj without-last marked-as-last)]
          {:methods methods
           :first-line first-line
           :last-line last-line}
          )))))

; The below uses the react snippets - TODO: check if they are available and use
; them instead
; (defn create-method [class mneumonic]
;   (jump-to-line (:first-line class))
;   (#*feedkeys (str "o" mneumonic "\<tab>") "m"))

(defn create-method [class mneumonic]
  (let [fname (function-mneumonics mneumonic)]
    (jump-to-line (:first-line class))
    (norm (str "o" (definition-for fname) "\<CR>},\<CR>\<ESC>kO"))
    (#*feedkeys "S" "n")))

(defn fancy-lookup [bang mneumonic]
  (let [begin-state (#*winsaveview)
        is-bang (not (zero? bang)) ; since this is created by vim equality
        class (parse-class)
        fname (function-mneumonics mneumonic)
        methods (filter #(= (:name %) fname) (:methods class))
        found (not (empty? methods))]
    (when found
      ; we want to add the original point to the jump list
      (#*winrestview begin-state)
      (norm "m'")
      (jump-to-line (:start-line (first methods)))
      (norm "zz"))
    (when-not found
      (when-not is-bang
        (echo
          (str "Did not find " fname " in this class, call with ! to create."))
        (#*winrestview begin-state))
      (when is-bang (create-method class mneumonic)))))

(execute "command! -bang -nargs=* R call plugin#respond#fancy_lookup(\"<bang>\"==\"!\", <f-args>)")

(defn method-containing-line [class lnum]
  (let [methods (:methods class)
        valid-methods (filter #(<= (:start-line %) lnum (:end-line %))
                              methods)]
    (if-not (empty? valid-methods)
      (first valid-methods))))
    

(defn create-handler []
  (let [begin-state (#*winsaveview)
        class (parse-class)
        _ (#*winrestview begin-state)
        fname (first (re-find #"\{this\.\zs.*\ze\}" (#*expand "<cWORD>")))
        methods (filter #(= (:name %) fname) (:methods class))
        found (not (empty? methods))]
    (when found
      ; we want to add the original point to the jump list
      (#*winrestview begin-state)
      (norm "m'")
      (jump-to-line (:start-line (first methods))))
    (when-not found
      (let [this-method (method-containing-line class (#*line "."))
            ending-line (:end-line this-method)
            command (str (if (:is-last this-method) "A,\<ESC>" "")
                         "o\<CR>" fname ": function () {\<CR>}"
                         (if (:is-last this-method) "" ","))]
        (jump-to-line ending-line)
        (norm command)
        (#*feedkeys "O" "n")))))

(execute "command! -nargs=* Rj call plugin#respond#create_handler(\"<bang>\"==\"!\", <f-args>)")
